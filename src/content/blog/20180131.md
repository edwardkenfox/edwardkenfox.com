+++
date = "2018-01-31T08:47:57+09:00"
title = "The Important Lessons TCP Taught Me"
url = "/blog/the-important-lessons-tcp-taught-me"

+++

<style>
section.main .content .markdown ul.quote li {
  list-style-type: none;
}
</style>

あるいはSlackやGitHubを使ってコミュニケーションをとったり開発する際に自分が気を付けていること／実践していること。

## 1. 光は遅い。人間はもっと遅い。

いくら通信のレイテンシを下げたとしても、光の速度を超えることはできない。光は宇宙で一番速いものではあるが、その光をもってしても日本・アメリカ間の通信には片道30ms程度かかってしまう。3回やり取りがあるだけで100msである。30msは怪しいが、100msの遅延は人間にも知覚できる。

RTT（= Round-Trip Time）を多く必要とするTCPのような通信プロトコルでは、レイテンシを減らすこと以上にRTTの回数を減らすことが通信全体の最適化にとって重要である。

![eefa1170a673da0140efe1ece7a2884b.svg (26.8 kB)](https://img.esa.io/uploads/production/attachments/2285/2018/01/21/6313/5876393c-7a56-42f5-b712-330e3c3d5ef7.svg)

<p style="text-align: right; margin-top: -24px;"><i style="font-size: 11px;">よく見るアレ</i></p>

人間のコミュニケーションもまた然りで、チャット上での（どちらかというと）同期的なコミュニケーション、あるいはコードレビューやドキュメントツール上での非同期的なコミュニケーションいずれにおいても、下げられるレイテンシには限界がある。このため、RTTの回数を減らすことがコミュニケーションを効率よくスムーズにするための鍵となる。

例えば以下のようなやり取りを見てみる。

<ul class="quote" style="border: 1px solid #ddd; padding: 12px; margin: 12px; list-style: none;">
<li>A 「Bさん、AwesomeClassはどこで使われているか分かりますか？」</li>
<li>B 「AwesomeControllerですね。」</li>
<li>A 「ありがとうございます。AwesomeControllerを消そうと思っているので、AwesomeClassも一緒に消して良いかどうかを気にしています。」</li>
<li>B 「AwesomeClassが主に使われるのはAwesomeControllerですが、例外的にNotSoAwesomeControllerからも一部利用されています。」</li>
<li>A 「なるほど。NotSoAwesomeClassは色々な場所から使われているので、AwesomeControllerとAwesomeClassをいちどに消すのは止めた方が良いでしょうか？」</li>
<li>B 「そうですね。」</li>
<li>A 「わかりました。ここではAwesomeControllerを消すだけにします。ありがとうございました。」</li>
</ul>

このやり取りでは3.5往復 = 3.5 RTTのやり取りをもって最終的な結論が出されている。
次に、このやり取りをもう少しスムーズにしてみた場合の例を見てみる。

<ul class="quote"  style="border: 1px solid #ddd; padding: 12px; margin: 12px; list-style: none;">
<li>A 「Bさん、AwesomeClassはどこで使われているか分かりますか？AwesomeControllerを消そうと思っているのですが、AwesomeClassも一緒に消して良いかどうかが分からなくて。」</li>
<li>B 「AwesomeClassが主に使われるのはAwesomeControllerですが、例外的にNotSoAwesomeClassからも一部利用されています。NotSoAwesomeClassは色々な場所から使われているので、AwesomeControllerとAwesomeClassをいちどに消すのは修正が大きくなってしまいそうです。」</li>
<li>A 「わかりました。ここではAwesomeControllerを消すだけにします。ありがとうございました。」</li>
</ul>

後者のやり取りで注目すべきは、最初のコメントの時点でAさんがBさんに質問する際にその意図を共有している点。これにより、BさんはAさんがやろうとしていることの背景を把握した上で回答できるので、1度目の返答でNotSoAwesomeClassについて言及している。またBさんもAさんの質問に対して回答するだけなく、Aさんが質問した目的である「AwesomeClassを消せるかどうか」という論点まで踏み込んで回答しているので、最終的にAさんが結論を導き出すまでのやり取りが1.5 RTTで済んだ。

後者の例では1度に伝達する情報の量が増えたので、回答に要する時間（= レイテンシ）は多少増加すると思われる。それでも上記の例を見る限りは、（特に非同期的なコミュニケーションにおいては）RTTが少ない方がトータルでかかる時間は少ないことは感覚的に理解できるだろう。

## 2. パケットは遅れたりロストしたりする

TCPではパケットの送達を保証するため、パケットがロスした場合はそのパケットを再送する仕組みになっている。このときパケットの順序がおかしくなってしまわないよう、後続のパケットの送信は待たされることになり、結果として通信にかかる時間は伸びてしまう。この現象はHOL Blocking（= Head Of Line Blocking）と呼ばれ、パケット送受信の順序がキッチリと守られているTCPの仕組みゆえの問題点でもある。

HOL Blockingは現実世界でも起こりうる。たとえば、二者間でコードの方針について議論し、その結果を第三者に伝えるやり取りの例を見てみる。

<ul class="quote"  style="border: 1px solid #ddd; padding: 12px; margin: 12px; list-style: none;">
<li>A 「Bさん、TheNewFeatureの実装方法について相談です。αの方針はコードがキレイですが実装に時間がかかります。βの方針は実装はすぐできますが、設計的にはイマイチです。」</li>
<li>B 「このコードは以前から直したいと思っていたところなので、時間をかけてでもαの方針で実装する方が良いと思いますね。」</li>
<li>A 「わかりました、ではαでいきたいと思います。Cさん、TheNewFeatureについてはαの方針で実装を進めることになったので、Cさんのタスクもその前提で進めてください。」</li>
<li>C: 「了解です。ありがとうございます。」</li>
</ul>

このやり取りを見ると、Aさんの質問にBさんが回答し議論がまとまって初めてCさんへの情報共有がされている。おそらくαかβによってCさんのタスクに影響が出るのであろう。Aさんの質問に対するBさんの回答やその後の議論がスムーズに行けばこれでも問題はないが、必ずしもそうなるとは限らない。別の例を見てみる。

<ul class="quote"  style="border: 1px solid #ddd; padding: 12px; margin: 12px; list-style: none;">
<li>A 「Bさん、TheNewFeatureの実装方法について相談です。αの方針はコードがキレイですが実装に時間がかかります。βの方針は実装はすぐできますが、設計的にはイマイチです。Cさん、上記のようにTheNewFeatureはαかβのどちらかの方針で進めることになるので、Cさんのタスクもその前提で進めてください。決定した際はふたたび連絡します。」</li>
<li>C: 「了解です。よろしくお願いします。」</li>
<li>B 「このコードは以前から直したいと思っていたところなので、時間をかけてでもαの方針で実装する方が良いと思いますね。」</li>
<li>A 「わかりました、ではαでいきたいと思います。Cさん、TheNewFeatureについてはαの方針で実装を進めることになったので、あらためて共有です。」</li>
<li>C: 「👍」</li>
</ul>

最終的な結論が決まっていない段階であっても、Aさんはαかβどちらかの方針でタスクが進むことをCさんに最初の段階で共有している。Bさんからの回答に時間がかかったり、あるいはAさんとBさんの議論が白熱したとしてもCさんは前もって実装方針についてαかβのどちらかになることを把握できているので、その心づもりをもって並行して自分のタスクを進めることができる。

## 3. 情報は受信者が受け取れて初めて価値がある

TCPにはネットワークの輻輳を防ぐための仕組みがいくつかある。TCPでやり取りするパケットの量はTCP window scaling optionという設定によって決まるが、コネクションが確立した時点ではwindow sizeは小さく始め、徐々にwindow sizeを大きくしていくことで通信のスループットが上がるように設計されている。反対にいうと、パケットの受信側のwindow sizeによってやり取りできる通信量は制限される。

同じことが人間のコミュニケーションにも当てはまる。先に書いたことと矛盾するように聞こえるかもしれないが、伝えようとしている事柄の文脈や受け手の習熟度、あるいは受け手が他に抱えているタスクの量などを一切考慮せずになんでもかんでも丸投げしてしまうと、かえってコミュニケーションの効率は悪くなる。会社に入って間もないの人にレビューを投げる場合や、そもそも技術的な習熟度が高くない相手に対してコミュニケーションをとる際に、相手が受け取れるであろう情報の量や質・表現をしないと、意図したとおりのコミュニケーションがとれない可能性がある。相手が何を・どれくらい・どうすれば理解できるのか、をはじめに確認しておくことが肝心だ。

## 4. 通信の終了

TCPは接続してパケットをやり取りできるようになるまでのコストが高いので、1度確立したコネクションを使い回したいことがある。keepaliveという仕組みを使えば、確立済みのコネクションが有効であろうかを確認でき、コネクション確立のコストを節約した形でふたたび通信を開始することができる。

しかしながら、終わったコネクションをいつまでもとっておくのは無駄なので、必要なくなったコネクションはFINパケットを送って閉じることが必要である。適切にコネクションを閉じるためにも、keepaliveを利用する際はtimeoutを設定するべきだと言える。

人間の脳はコンピュータほどのメモリを備えていないので、多くのコミュニケーションを並行させることは大きな負担を強いる。終わったかどうかが分からない事柄が頭の片隅に残ってしまっているがゆえに、ある作業から別の作業へのスイッチングコストとなってしまうことは稀によくある。1対1でのコミュニケーションにおける会話やコメントのやりとりは終了したことを明示的に確認せずとも問題ないことが多いが、1対多や多対多となると完了条件が示すことは意外と重要だったりする。またkeepaliveなコネクションにtimeoutを設けるように、期限を提示した上で回答を求めることもけっこう大事。

## 補足

記事の内容的には「[人生の全てはTCP/IPに学んだ](http://www.geekpage.jp/blog/?id=2008/1/29)」と「[コードレビューで気をつけていること](https://qiita.com/kinu/items/7e27e5734472b629e34f)」 をマッシュアップした感じだろうか。開発・仕事上のコミュニケーションに的を絞って、自分が普段考えていること、取り組んでいることを書き記してみた。本文中では技術的な内容の深い掘り下げはしていないが、書くにあたって参考にした記事は以下の通り。

-   [Head of Line Blocking - High Performance Web 2015](https://qiita.com/Jxck_/items/0dbdee585db3e21639a8)
-   [TLSとQUICハンドシェーク](https://qiita.com/tatsuhiro-t/items/2c4e40923c5e359ca235)
-   [トランスポート層における Web 最適化](http://clown.hatenablog.jp/entry/20100711/1278847485)
- [信頼性のある通信を実現するTCPプロトコル](http://www.atmarkit.co.jp/ait/articles/0401/29/news080_2.html)
- [TCP window scale option](https://en.wikipedia.org/wiki/TCP_window_scale_option)

